import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  Typography,
  Avatar,
  Button,
  Chip,
  useTheme,
  Divider,
  useMediaQuery,
  Fab,
  Dialog,
  TextField,
  IconButton,
  Grid,
  CircularProgress,
  Paper,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Collapse,
  Zoom,
  Tooltip,
  LinearProgress
} from '@mui/material';
import {
  VolumeUp as VolumeUpIcon,
  Add as AddIcon,
  Send as SendIcon,
  Refresh as RefreshIcon,
  ExpandMore as ExpandMoreIcon,
  Close as CloseIcon,
  Message as MessageIcon,
  ArrowDownward 
} from '@mui/icons-material';
import ClearIcon from '@mui/icons-material/Clear';
import PersonIcon from '@mui/icons-material/Person';
import ReactMarkdown from 'react-markdown';

// API URL
const API_BASE_URL = "";


// Numero di scambi in una conversazione completa
const CONVERSATION_LENGTH = 10; 

// Tema Dracula
const draculaTheme = {
  background: '#282a36',
  currentLine: '#44475a',
  selection: '#44475a',
  foreground: '#f8f8f2',
  comment: '#6272a4',
  cyan: '#8be9fd',
  green: '#50fa7b',
  orange: '#ffb86c',
  pink: '#ff79c6',
  purple: '#bd93f9',
  red: '#ff5555',
  yellow: '#f1fa8c'
};

// Stile per l'animazione dei punti di digitazione e scrollbar nascosta
const animationKeyframes = `
  @keyframes bounce {
    0%, 60%, 100% { transform: translateY(0); }
    30% { transform: translateY(-5px); }
  }
  
  /* Nascondere scrollbar ma mantenere la funzionalità */
  .hide-scrollbar {
    overflow-y: auto;
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer e Edge */
  }
  
  .hide-scrollbar::-webkit-scrollbar {
    display: none; /* Chrome e Safari */
  }
`;

// Componente per l'indicatore di digitazione AI1
const AI1TypingIndicator = () => (
  <div style={{ 
    backgroundColor: 'rgba(68,71,90,0.7)',
    color: '#f8f8f2',
    margin: '10px 0',
    padding: '10px 20px',
    borderRadius: '10px',
    display: 'flex',
    alignItems: 'center',
    float: 'left',
    clear: 'both',
    width: 'fit-content',
    maxWidth: '80%'
  }}>
    <div style={{ 
      width: '30px',
      height: '30px',
      borderRadius: '50%',
      backgroundColor: '#bd93f9',
      color: '#f8f8f2',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      marginRight: '10px',
      fontWeight: 'bold'
    }}>
      AI1
    </div>
    <div style={{ display: 'flex', alignItems: 'center' }}>
      <div style={{ 
        width: '8px', 
        height: '8px', 
        backgroundColor: 'white', 
        borderRadius: '50%',
        margin: '0 3px',
        animation: 'bounce 1.3s infinite'
      }}></div>
      <div style={{ 
        width: '8px', 
        height: '8px', 
        backgroundColor: 'white', 
        borderRadius: '50%',
        margin: '0 3px',
        animation: 'bounce 1.3s infinite',
        animationDelay: '0.15s'
      }}></div>
      <div style={{ 
        width: '8px', 
        height: '8px', 
        backgroundColor: 'white', 
        borderRadius: '50%',
        margin: '0 3px',
        animation: 'bounce 1.3s infinite',
        animationDelay: '0.3s'
      }}></div>
    </div>
  </div>
);

// Componente per l'indicatore di digitazione AI2
const AI2TypingIndicator = () => (
  <div style={{ 
    backgroundColor: 'rgba(98,114,164,0.7)',
    color: '#f8f8f2',
    margin: '10px 0',
    padding: '10px 20px',
    borderRadius: '10px',
    display: 'flex',
    alignItems: 'center',
    float: 'right',
    clear: 'both',
    width: 'fit-content',
    maxWidth: '80%'
  }}>
    <div style={{ 
      width: '30px',
      height: '30px',
      borderRadius: '50%',
      backgroundColor: '#ff79c6',
      color: '#f8f8f2',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      marginRight: '10px',
      fontWeight: 'bold'
    }}>
      AI2
    </div>
    <div style={{ display: 'flex', alignItems: 'center' }}>
      <div style={{ 
        width: '8px', 
        height: '8px', 
        backgroundColor: 'white', 
        borderRadius: '50%',
        margin: '0 3px',
        animation: 'bounce 1.3s infinite'
      }}></div>
      <div style={{ 
        width: '8px', 
        height: '8px', 
        backgroundColor: 'white', 
        borderRadius: '50%',
        margin: '0 3px',
        animation: 'bounce 1.3s infinite',
        animationDelay: '0.15s'
      }}></div>
      <div style={{ 
        width: '8px', 
        height: '8px', 
        backgroundColor: 'white', 
        borderRadius: '50%',
        margin: '0 3px',
        animation: 'bounce 1.3s infinite',
        animationDelay: '0.3s'
      }}></div>
    </div>
  </div>
);

// Funzione migliorata per pulire il titolo
const cleanTitle = (title) => {
  if (!title) return 'Loading Conversation...';
  
  // 1. Rimuove [ITA] o [ENG] all'inizio
  let cleanedTitle = title.replace(/^\s*\[(ITA|ENG)\]\s*/i, '');
  
  // 2. Rimuove timestamp nel formato YYYY-MM-DD HH:MM:SS alla fine
  cleanedTitle = cleanedTitle.replace(/\s-\s\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}.*$/, '');
  
  // 3. Gestisce formato "brainstorming-[argomento]-[timestamp]"
  if (cleanedTitle.match(/^brainstorming-.*-\d+$/i)) {
    // Estrae la parte centrale (l'argomento) usando una regex più flessibile
    const match = cleanedTitle.match(/^brainstorming-(.*?)-\d+$/i);
    if (match && match[1]) {
      // Sostituisce underscore con spazi e capitalizza prima lettera di ogni parola
      cleanedTitle = match[1].replace(/_/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }
  }
  
  // 4. Gestisce "Brainstorming su/on [argomento]" formato 
  const brainstormingMatch = cleanedTitle.match(/^Brainstorming (?:su|on) (.*)$/i);
  if (brainstormingMatch && brainstormingMatch[1]) {
    cleanedTitle = brainstormingMatch[1];
  }
  
  return cleanedTitle;
};

function ConversationDetails({ conversationId, mostRecentConversation }) {
  // Stati principali
  const [messages, setMessages] = useState([]);
  const [summary, setSummary] = useState(null);
  const [formattedTitle, setFormattedTitle] = useState('Loading Conversation...');
  const [message, setMessage] = useState("");
  const [haiku, setHaiku] = useState('');
  const [botPersonalities, setBotPersonalities] = useState({ AI1: null, AI2: null });
  const [lastUpdated, setLastUpdated] = useState(new Date());
  const [error, setError] = useState(null);
  const [topic, setTopic] = useState("");
  const [progress, setProgress] = useState(0);
  const [rawTitle, setRawTitle] = useState(""); // Aggiungiamo uno stato per il titolo grezzo
  
  // Stati UI
  const [canSendMessage, setCanSendMessage] = useState(true);
  const [showMessages, setShowMessages] = useState(false); // Di default non mostriamo i messaggi per conversazioni chiuse
  const [showHaiku, setShowHaiku] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [userHasScrolled, setUserHasScrolled] = useState(false);
  const [showAI1Typing, setShowAI1Typing] = useState(false);
  const [showAI2Typing, setShowAI2Typing] = useState(false);
  const [isProcessingUserMessage, setIsProcessingUserMessage] = useState(false);
  const [mobileInputExpanded, setMobileInputExpanded] = useState(false);
  const [open, setOpen] = useState(false);
  const [sentMessage, setSentMessage] = useState(""); // Per tenere traccia del messaggio inviato
  const [lastMessageId, setLastMessageId] = useState(null);
  
  // References
  const messagesEndRef = useRef(null);
  const lastMessageRef = useRef(null);
  const messagesContainerRef = useRef(null);
  const isInitialRender = useRef(true);
  const scrollTimer = useRef(null);
  const isManualScroll = useRef(false);

  // Media queries
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const fullScreen = useMediaQuery(theme.breakpoints.down('sm'));

  const isInitialLoad = useRef(true);
  
  // Debug e logging
  const DEBUG = true;
  const debug = (message) => {
    if (DEBUG) {
      console.log(`[ConversationDetails] ${message}`);
    }
  };
  
  // Verifica se questa è la conversazione attiva (più recente)
  const isActiveConversation = conversationId === mostRecentConversation;
  
  // Effetto per aggiornare il titolo formattato ogni volta che rawTitle cambia
  useEffect(() => {
    if (rawTitle) {
      const cleaned = cleanTitle(rawTitle);
      console.log(`Raw title: ${rawTitle}, Cleaned title: ${cleaned}`);
      setFormattedTitle(cleaned);
    }
  }, [rawTitle]);
  
  // Calcola il progresso della conversazione
  useEffect(() => {
    if (messages.length > 0) {
      // Count only AI1 and AI2 messages
      const aiMessages = messages.filter(msg => msg.speaker === 'AI1' || msg.speaker === 'AI2');
      console.log(`AI Messages: ${aiMessages.length} of expected 20`);
      
      // Calculate progress percentage (out of 20 AI messages total)
      const calculatedProgress = Math.min(100, Math.round((aiMessages.length / 20) * 100));
      console.log(`Progress calculation: ${aiMessages.length} messages out of 20 = ${calculatedProgress}%`);
      
      setProgress(calculatedProgress);
    } else {
      setProgress(0);
    }
  }, [messages]);
  
  // Funzione per identificare messaggi duplicati dell'utente
  const hasDuplicateUserMessages = (msgList) => {
    if (!msgList || msgList.length < 2) return false;
    
    // Raccoglie messaggi dell'utente
    const userMessages = msgList.filter(msg => msg.speaker === 'User');
    
    // Controlla messaggi duplicati confrontando testo
    const messageCounts = {};
    for (const msg of userMessages) {
      const content = msg.message.trim();
      messageCounts[content] = (messageCounts[content] || 0) + 1;
      
      // Se troviamo una duplicazione, restituisce true
      if (messageCounts[content] > 1) {
        return true;
      }
    }
    return false;
  };
  

  
  
  
  // Resets all state when conversation changes
  useEffect(() => {
    debug(`Conversation changed to: ${conversationId}, most recent: ${mostRecentConversation}`);
    
    // Reset all states
    setMessages([]);
    setSummary(null);
    setHaiku('');
    // Solo per conversazioni attive, mostra i messaggi per default
    setShowMessages(conversationId === mostRecentConversation);
    setShowHaiku(false);
    setUserHasScrolled(false);
    setShowAI1Typing(false);
    setShowAI2Typing(false);
    setFormattedTitle('Loading Conversation...');
    setRawTitle(''); // Reset the raw title
    setBotPersonalities({ AI1: null, AI2: null });
    setIsProcessingUserMessage(false);
    setMobileInputExpanded(false);
    setSentMessage("");
    setCanSendMessage(true); // Make sure to enable sending with a new conversation
    setProgress(0);
    setTopic("");
    setLastMessageId(null);
    isInitialRender.current = true;
    isInitialLoad.current = true;
    
    // Only proceed if we have a valid conversation ID
    if (!conversationId) return;
    
    // Load all data for this conversation
    loadConversationData();
    
    // Setup polling ONLY for the most recent conversation
    let intervalId;
    if (conversationId === mostRecentConversation) {
      debug("Setting up polling for most recent conversation");
      intervalId = setInterval(() => {
        if (conversationId === mostRecentConversation) {
          fetchMessages();
        }
      }, 3000);
    }
    
    return () => {
      if (intervalId) clearInterval(intervalId);
    };
  }, [conversationId, mostRecentConversation]);
  
  // Load all conversation data
  const loadConversationData = async () => {
    if (!conversationId) return;
    
    setIsLoading(true);
    
    try {
      debug(`Loading conversation data for ID: ${conversationId}`);
      
      // 1. Fetch conversation details
      const detailsResponse = await fetch(`${API_BASE_URL}/api/conversations/${conversationId}`);
      
      if (detailsResponse.ok) {
        const detailsData = await detailsResponse.json();
        if (detailsData) {
          console.log("Conversation details:", detailsData);
          // Salva il titolo grezzo e lascia che l'effetto si occupi di formattarlo
          if (detailsData.title) {
            setRawTitle(detailsData.title);
          }
          if (detailsData.topic) {
            setTopic(detailsData.topic);
          }
        }
      }
      
      // 2. Fetch summary (if available)
      try {
        const summaryResponse = await fetch(`${API_BASE_URL}/api/conversations/${conversationId}/summary`);
        
        if (summaryResponse.ok) {
          const summaryData = await summaryResponse.json();
          console.log("Summary data received:", summaryData); // Debug log
          
          // Make sure we're checking for the right condition
          if (summaryData && Object.keys(summaryData).length > 0) {
            setSummary(summaryData);
            // Imposta il titolo dal sommario se presente
            if (summaryData.title) {
              setRawTitle(summaryData.title);
            }
            if (summaryData.topic) {
              setTopic(summaryData.topic);
            }
            if (summaryData.haiku) {
              setHaiku(summaryData.haiku);
            }
          } else {
            console.log("Empty summary data received"); // Debug log
          }
        } else {
          console.log(`Summary fetch failed with status: ${summaryResponse.status}`);
        }
      } catch (summaryError) {
        console.error('Error fetching summary:', summaryError);
      }
      
      // 3. Fetch bot personalities (if available)
      try {
        const personalitiesResponse = await fetch(`${API_BASE_URL}/api/conversations/${conversationId}/personalities`);
        
        if (personalitiesResponse.ok) {
          const personalitiesData = await personalitiesResponse.json();
          if (personalitiesData) {
            setBotPersonalities(personalitiesData);
          }
        }
      } catch (personalitiesError) {
        console.error('Error fetching bot personalities:', personalitiesError);
      }
      
      // 4. Fetch messages
      await fetchMessages();
      
    } catch (error) {
      console.error('Error loading conversation data:', error);
      setError('Failed to load conversation data');
    } finally {
      setIsLoading(false);
    }
  };
  
  // Fetch messages and update application state
  const fetchMessages = async () => {
    if (!conversationId) return;
    
    try {
      debug(`Fetching messages for conversation ID: ${conversationId}`);
      const response = await fetch(`${API_BASE_URL}/api/conversations/${conversationId}/messages`);
      
      if (!response.ok) {
        throw new Error(`Network error: ${response.status}`);
      }
      
      const data = await response.json();
      debug(`Received ${data.length} messages from server`);
      
      // Se ci sono duplicati esatti dei messaggi dell'utente, filtra
      if (hasDuplicateUserMessages(data)) {
        debug("FOUND DUPLICATE USER MESSAGES! Filtering...");
        
        // Filtro per messaggi duplicati: teniamo solo il primo per ogni testo unico
        const uniqueMessages = [];
        const seenUserMessages = new Set();
        
        for (const msg of data) {
          // Se è un messaggio utente, controlla se l'abbiamo già visto
          if (msg.speaker === 'User') {
            const content = msg.message.trim();
            if (seenUserMessages.has(content)) {
              // Skip this message as we've seen it before
              debug(`Skipping duplicate user message: "${content}"`);
              continue;
            }
            seenUserMessages.add(content);
          }
          uniqueMessages.push(msg);
        }
        
        setMessages(uniqueMessages);
        debug(`Filtered ${data.length - uniqueMessages.length} duplicate messages`);
      } else {
        setMessages(data);
      }
      
      // Check if we have a new message
      const newLastMessageId = data.length > 0 ? data[data.length - 1].id : null;
      const isNewMessage = newLastMessageId !== lastMessageId && lastMessageId !== null;
      
      // Update last message ID
      setLastMessageId(newLastMessageId);
      
      // Only auto-scroll if:
      // 1. This is the initial load of this conversation (isInitialRender)
      // 2. OR we have a new message AND user hasn't manually scrolled up
      
      
      // No longer initial render after first load
      isInitialRender.current = false;
      
      // Controlla se il messaggio che abbiamo inviato è ora nell'elenco
      if (sentMessage && data.some(msg => msg.speaker === 'User' && msg.message === sentMessage)) {
        debug("Found sent message in server response, clearing.");
        setSentMessage("");
      }
      
      setLastUpdated(new Date());
      updateApplicationState(data);
      
    } catch (error) {
      console.error('Error fetching messages:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Update entire application state based on messages
  const updateApplicationState = (messagesList) => {
    if (!messagesList || messagesList.length === 0) {
      debug("No messages yet, enabling send button and hiding typing indicators");
      setCanSendMessage(true);
      setIsProcessingUserMessage(false);
      setShowAI1Typing(false);
      setShowAI2Typing(false);
      return;
    }
    
    // Debug log conversation sequence
    if (DEBUG) {
      const sequence = messagesList.map(msg => msg.speaker).join(' -> ');
      debug(`Message sequence: ${sequence}`);
    }
    
    // Get the last two messages for better context
    const lastMessage = messagesList[messagesList.length - 1];
    const secondLastMessage = messagesList.length > 1 ? messagesList[messagesList.length - 2] : null;
    
    debug(`Last message from: ${lastMessage.speaker}`);
    if (secondLastMessage) {
      debug(`Second last message from: ${secondLastMessage.speaker}`);
    }
    
    // REGOLE PER DETERMINARE GLI STATI:
    
    // 1. Se l'ultimo messaggio è di AI2, la risposta è completa
    if (lastMessage.speaker === 'AI2') {
      debug("Last message from AI2 - enabling send button and hiding typing indicators");
      setCanSendMessage(true);
      setIsProcessingUserMessage(false);
      setShowAI1Typing(true);
      setShowAI2Typing(false);
    }
    // 2. Se l'ultimo messaggio è dell'utente, mostra AI1 typing
    else if (lastMessage.speaker === 'User') {
      debug("Last message from User - disabling send button and showing AI1 typing");
      setCanSendMessage(false);
      setIsProcessingUserMessage(true);
      setShowAI1Typing(true);
      setShowAI2Typing(false);
    }
    // 3. Se l'ultimo messaggio è di AI1, mostra AI2 typing
    else if (lastMessage.speaker === 'AI1') {
      debug("Last message from AI1 - keeping send button disabled and showing AI2 typing");
      setCanSendMessage(false);
      setIsProcessingUserMessage(true);
      setShowAI1Typing(false);
      setShowAI2Typing(true);
    }
    // 4. Se l'ultimo messaggio è di System, abilita l'invio (messaggi rifiutati)
    else if (lastMessage.speaker === 'System') {
      debug("Last message from System - enabling send button and hiding typing indicators");
      setCanSendMessage(true);
      setIsProcessingUserMessage(false);
      setShowAI1Typing(false);
      setShowAI2Typing(false);
    }
  };
  
  // Send message to the server
  const sendMessage = async (userMsg) => {
    try {
      debug(`Sending message to server: "${userMsg}"`);
      
      const response = await fetch(`${API_BASE_URL}/api/conversations/${conversationId}/messages`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: userMsg,
          speaker: 'User'
        })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to send message: ${response.status}`);
      }
      
      debug("Message sent successfully to server");
      
      // Salva il messaggio inviato per poterlo verificare nelle future risposte
      setSentMessage(userMsg);
      
      // Mostra immediatamente l'indicatore di digitazione
      setShowAI1Typing(true);
      
      // Aggiorna i messaggi dopo un breve ritardo
      setTimeout(() => {
        fetchMessages();
      }, 1000);
      
      return true;
    } catch (error) {
      console.error('Error sending message:', error);
      setError(`Failed to send message: ${error.message}`);
      return false;
    }
  };
  
  // Handle send button click
  const handleSendMessage = async () => {
    if (!message.trim() || !conversationId || !canSendMessage) {
      debug("Message send aborted - conditions not met");
      return;
    }
    
    try {
      // Disable sending immediately
      setCanSendMessage(false);
      setIsProcessingUserMessage(true);
      
      // Store message locally
      const userMsg = message.trim();
      
      // Clear input and close dialogs
      setMessage("");
      setOpen(false);
      setMobileInputExpanded(false);
      
      // Reset scroll state
      setUserHasScrolled(false);
      
      // IMPORTANTE: Qui facciamo SOLO le operazioni lato client:
      // 1. Disabilitiamo l'invio
      // 2. Mostriamo l'indicatore di digitazione di AI1
      // 3. Inviamo il messaggio al server (NON mostriamo ancora il messaggio)
      setShowAI1Typing(true);
      
      // Send message to server
      const success = await sendMessage(userMsg);
      
      if (!success) {
        // If sending failed, re-enable button and hide typing
        setCanSendMessage(true);
        setIsProcessingUserMessage(false);
        setShowAI1Typing(false);
        return;
      }
      
    } catch (error) {
      console.error('Error in send message flow:', error);
      setError(`Failed to send message: ${error.message}`);
      
      // Re-enable on error
      setCanSendMessage(true);
      setIsProcessingUserMessage(false);
      setShowAI1Typing(false);
    }
  };
  
  // Auto-clear typing indicators after maximum wait time
  useEffect(() => {
    if (showAI1Typing || showAI2Typing) {
      const timeoutId = setTimeout(() => {
        debug("Auto-clearing typing indicators after timeout");
        setShowAI1Typing(false);
        setShowAI2Typing(false);
      }, 30000); // 30 seconds max wait
      
      return () => clearTimeout(timeoutId);
    }
  }, [showAI1Typing, showAI2Typing]);
  
  // Toggle messages visibility
  const handleToggleMessages = () => {
    setShowMessages(!showMessages);
    if (showHaiku) {
      setShowHaiku(false);
    }
    
    // Reset scroll state when toggling
    if (!showMessages) {
      setUserHasScrolled(false);
      isInitialRender.current = true;
    }
  };
  
  // Toggle haiku visibility
  const handleShowHaikuInline = () => {
    setShowHaiku(!showHaiku);
    if (showMessages) {
      setShowMessages(false);
    }
  };
  
  // Manual refresh
  const handleRefresh = () => {
    fetchMessages();
  };
  
  // Text-to-speech for summary
  const speakSummary = () => {
    if (!summary || !summary.summary) return;
    if (window.speechSynthesis.speaking) {
      window.speechSynthesis.cancel();
    } else {
      const utterance = new SpeechSynthesisUtterance(summary.summary);
      utterance.lang = 'en-US';
      utterance.rate = 0.7;
      let voices = window.speechSynthesis.getVoices().filter(voice => voice.lang === 'en-US');
      if (voices.length > 0) {
        utterance.voice = voices[0];
      }
      window.speechSynthesis.speak(utterance);
    }
  };
  
  // Toggle mobile input box
  const toggleMobileInput = () => {
    setMobileInputExpanded(!mobileInputExpanded);
  };
  
  // Close mobile input without sending
  const handleCloseMobileInput = () => {
    setMobileInputExpanded(false);
  };
  
  // Dialog controls
  const handleOpen = () => setOpen(true);
  const handleClose = () => setOpen(false);
  
  // Render message bubble
  const renderMessageBubble = (msg, index) => {
    const isLastMessage = index === messages.length - 1;
    
    // Styling based on speaker
    let backgroundColor = '#aeb9cc';
    let avatarColor = '#757575';
    let foregroundColor = '#f8f8f2';
    let floatDirection = 'left';

    if (msg.speaker === 'AI1') {
      backgroundColor = 'rgba(68,71,90,0.7)';
      avatarColor = '#bd93f9';
      foregroundColor = '#f8f8f2';
      floatDirection = 'left';
    } else if (msg.speaker === 'AI2') {
      backgroundColor = 'rgba(98,114,164,0.7)';
      avatarColor = '#ff79c6';
      foregroundColor = '#f8f8f2';
      floatDirection = 'right';
    } else if (msg.speaker === 'User') {
      backgroundColor = 'rgba(68,71,90,0.5)';
      avatarColor = '#757575';
      foregroundColor = '#f8f8f2';
      floatDirection = 'right';
    }

    return (
      <Box
        key={msg.id || `msg-${index}`} // Fallback to index if id is not available
        ref={isLastMessage ? lastMessageRef : null}
        sx={{
          backgroundColor,
          color: foregroundColor,
          margin: '10px 0',
          padding: '10px 20px',
          borderRadius: '10px',
          float: floatDirection,
          clear: 'both',
          maxWidth: '80%',
          transition: 'opacity 0.5s ease'
        }}
      >
        <Avatar
          sx={{
            marginRight: '10px',
            backgroundColor: avatarColor,
            color: '#f8f8f2',
            display: { sm: 'inline-flex', xs: 'none' }
          }}
        >
          {msg.speaker === 'User' ? <PersonIcon /> : msg.speaker}
        </Avatar>
        <Box>
          <ReactMarkdown>{msg.message}</ReactMarkdown>
          {msg.timestamp && (
            <Typography variant="caption" sx={{ opacity: 0.7, display: 'block' }}>
              {new Date(msg.timestamp).toLocaleTimeString()}
            </Typography>
          )}
        </Box>
      </Box>
    );
  };
  
  // Render bot personalities section
  const renderBotPersonalities = () => {
    const hasPersonalities = 
      botPersonalities.AI1 || botPersonalities.AI2;
      
    if (!hasPersonalities) return null;
    
    return (
      <Box sx={{ mb: 3 }}>
        <Accordion defaultExpanded={false}>
          <AccordionSummary
            expandIcon={<ExpandMoreIcon />}
            aria-controls="bot-personalities-content"
            id="bot-personalities-header"
            sx={{ color: draculaTheme.foreground }}
          >
            <Typography variant="h6">Bot Personalities</Typography>
          </AccordionSummary>
          <AccordionDetails>
            <Grid container spacing={2}>
              {botPersonalities.AI1 && (
                <Grid item xs={12} md={6}>
                  <Paper 
                    elevation={2} 
                    sx={{ 
                      p: 2, 
                      bgcolor: 'rgba(68,71,90,0.5)',
                      height: '100%',
                      color: draculaTheme.foreground
                    }}
                  >
                    <Typography variant="h6" sx={{ color: draculaTheme.purple, fontWeight: 'bold', mb: 1 }}>
                      AI1
                    </Typography>
                    <Typography variant="subtitle1" sx={{ fontWeight: 'bold', mb: 1 }}>
                      Personality:
                    </Typography>
                    <Typography variant="body2" sx={{ mb: 2 }}>
                      {botPersonalities.AI1.prompt}
                    </Typography>
                    <Typography variant="subtitle1" sx={{ fontWeight: 'bold', mb: 1 }}>
                      Background:
                    </Typography>
                    <Typography variant="body2">
                      {botPersonalities.AI1.description}
                    </Typography>
                  </Paper>
                </Grid>
              )}
              
              {botPersonalities.AI2 && (
                <Grid item xs={12} md={6}>
                  <Paper 
                    elevation={2} 
                    sx={{ 
                      p: 2, 
                      bgcolor: 'rgba(98,114,164,0.5)',
                      height: '100%',
                      color: draculaTheme.foreground
                    }}
                  >
                    <Typography variant="h6" sx={{ color: draculaTheme.pink, fontWeight: 'bold', mb: 1 }}>
                      AI2
                    </Typography>
                    <Typography variant="subtitle1" sx={{ fontWeight: 'bold', mb: 1 }}>
                      Personality:
                    </Typography>
                    <Typography variant="body2" sx={{ mb: 2 }}>
                      {botPersonalities.AI2.prompt}
                    </Typography>
                    <Typography variant="subtitle1" sx={{ fontWeight: 'bold', mb: 1 }}>
                      Background:
                    </Typography>
                    <Typography variant="body2">
                      {botPersonalities.AI2.description}
                    </Typography>
                  </Paper>
                </Grid>
              )}
            </Grid>
          </AccordionDetails>
        </Accordion>
      </Box>
    );
  };

  // Stile base container - usa il tema Dracula per tutti i dispositivi
  const containerStyle = {
    backgroundColor: draculaTheme.background,
    color: draculaTheme.foreground,
    minHeight: '100vh',
    position: 'relative',
    padding: '10px',
    border: 'none',
    outline: 'none'
  };

  return (
    <div style={containerStyle}>
      {/* Animation style for typing dots and hidden scrollbar */}
      <style>{animationKeyframes}</style>
      
      {/* Loading indicator */}
      {isLoading && (
        <CircularProgress
          sx={{ position: 'absolute', top: 10, right: 10, zIndex: 9999 }}
        />
      )}
      
      {/* Error display */}
      {error && (
        <Typography color="error" sx={{ mt: 2, mb: 2 }}>
          {error}
        </Typography>
      )}
      
      {/* Header with title e refresh button */}
      <Box sx={{ 
        display: 'flex', 
        flexDirection: 'column',
        marginTop: '10px', 
        marginBottom: '5px' 
      }}>
        <Box sx={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          alignItems: 'center'
        }}>
          <Typography 
            variant="h4" 
            sx={{ 
              color: draculaTheme.foreground
            }}
          >
            {formattedTitle}
          </Typography>
          <Box>
            <Typography 
              variant="caption" 
              sx={{ 
                mr: 1,
                color: draculaTheme.comment
              }}
            >
              Updated: {lastUpdated.toLocaleTimeString()}
            </Typography>
            <IconButton 
              onClick={handleRefresh} 
              disabled={isLoading}
              sx={{ 
                color: draculaTheme.foreground
              }}
            >
              <RefreshIcon />
            </IconButton>
          </Box>
        </Box>
        
        {/* Progress bar - SOLO per conversazioni attive/in corso */}
        {isActiveConversation && (
          <Box sx={{ width: '100%', mt: 1, mb: 1 }}>
            <Typography 
              variant="caption" 
              display="block" 
              sx={{ 
                mb: 1,
                color: draculaTheme.comment
              }}
            >
              Conversation progress: {progress}%
            </Typography>
            <LinearProgress 
              variant="determinate" 
              value={progress} 
              sx={{ 
                height: 8, 
                borderRadius: 2,
                backgroundColor: 'rgba(40, 42, 54, 0.5)',
                '& .MuiLinearProgress-bar': {
                  backgroundColor: draculaTheme.purple
                }
              }} 
            /> 
          </Box>
        )}
      </Box>
      
      <Divider sx={{ 
        marginTop: '10px', 
        marginBottom: '20px',
        backgroundColor: draculaTheme.comment
      }} />
      
      {/* Bot personalities section */}
      {renderBotPersonalities()}

      {/* Summary section */}
      {summary && summary.summary && (
        <>
          <Typography 
            variant="h5"
            sx={{ 
              color: draculaTheme.foreground
            }}
          >
            Summary
          </Typography>
          <IconButton 
            onClick={speakSummary}
            sx={{ 
              color: draculaTheme.foreground
            }}
          >
            <VolumeUpIcon />
          </IconButton>
          <Box
            sx={{
              color: draculaTheme.foreground,
              margin: '10px 0',
              padding: '10px 20px',
              borderRadius: '5px',
              backgroundColor: 'rgba(40, 42, 54, 0.3)'
            }}
          >
            <Box>{summary.summary}</Box>
            {summary.hashtags && (
              <Box
                sx={{
                  display: 'flex',
                  flexWrap: 'wrap',
                  gap: '10px',
                  marginTop: '10px'
                }}
              >
                {summary.hashtags.split(',').map((hashtag) => (
                  <Chip
                    key={hashtag.trim()}
                    label={hashtag.trim()}
                    variant="outlined"
                    size="small"
                    style={{ 
                      color: draculaTheme.foreground, 
                      borderColor: draculaTheme.comment
                    }}
                  />
                ))}
              </Box>
            )}
          </Box>
        </>
      )}

      {/* Action buttons (Show messages and Show haiku) in a single row with more space */}
      <Box sx={{ 
        display: 'flex', 
        justifyContent: 'flex-start', 
        gap: 4,  // Più spazio tra i bottoni
        mt: 4,   // Più margine superiore
        mb: 4    // Più margine inferiore
      }}>
        <Button
          variant="contained"
          onClick={handleToggleMessages}
          sx={{ 
            backgroundColor: showMessages ? draculaTheme.pink : draculaTheme.purple,
            '&:hover': {
              backgroundColor: showMessages ? draculaTheme.pink : draculaTheme.purple,
              opacity: 0.8
            }
          }}
        >
          {showMessages ? 'Hide Messages' : 'Show Messages'}
        </Button>

        {/* Solo se abbiamo l'haiku mostriamo il pulsante */}
        {haiku && (
          <Button
            variant="contained"
            onClick={handleShowHaikuInline}
            sx={{ 
              backgroundColor: showHaiku ? draculaTheme.pink : draculaTheme.purple,
              '&:hover': {
                backgroundColor: showHaiku ? draculaTheme.pink : draculaTheme.purple,
                opacity: 0.8
              }
            }}
          >
            {showHaiku ? 'Hide Haiku' : 'Show Haiku'}
          </Button>
        )}
      </Box>

      {/* Haiku content */}
      {showHaiku && haiku && (
        <Paper
          elevation={3}
          sx={{
            p: 3,
            mb: 4,
            backgroundColor: 'rgba(40, 42, 54, 0.5)',
            color: draculaTheme.foreground,
            borderLeft: `4px solid ${draculaTheme.orange}`,
            fontStyle: 'italic',
            lineHeight: 2
          }}
        >
          <Typography variant="body1" component="div" sx={{ whiteSpace: 'pre-line' }}>
            {haiku}
          </Typography>
        </Paper>
      )}

      {/* Messages section with typing indicators */}
      {showMessages && (
        <Box 
          ref={messagesContainerRef}
          className="hide-scrollbar" // Classe CSS per nascondere la scrollbar
          sx={{ 
            maxHeight: '60vh',
            p: 2,
            borderRadius: '8px',
            bgcolor: 'rgba(40, 42, 54, 0.3)',
            border: 'none',
            outline: 'none',
            overflow: 'auto'
          }}
        >
          {messages.length > 0 ? (
            <>
              {/* Messages from server */}
              {messages.map((msg, i) => renderMessageBubble(msg, i))}
              
              {/* Typing indicators */}
              {showAI1Typing && <AI1TypingIndicator />}
              {showAI2Typing && <AI2TypingIndicator />}
            </>
          ) : (
            <Typography 
              variant="body1" 
              sx={{ 
                textAlign: 'center', 
                my: 4,
                color: draculaTheme.comment
              }}
            >
              {isLoading ? 'Loading messages...' : 'No messages found for this conversation.'}
            </Typography>
          )}
          <div ref={messagesEndRef} style={{ clear: 'both' }} />
        </Box>
      )}

      {/* Desktop message input - only for most recent conversation */}
      {!isMobile && conversationId === mostRecentConversation && (
        <>
          {isProcessingUserMessage ? (
            <Fab
              sx={{
                position: 'fixed', 
                bottom: '16px', 
                right: '16px',
                backgroundColor: draculaTheme.purple
              }}
              disabled
              aria-label="processing"
            >
              <CircularProgress size={24} color="inherit" />
            </Fab>
          ) : (
            <Tooltip title={canSendMessage ? "Send a message" : "Please wait for bot response"}>
              <span style={{ position: 'fixed', bottom: '16px', right: '16px' }}>
                <Fab
                  sx={{
                    backgroundColor: draculaTheme.purple,
                    '&:hover': {
                      backgroundColor: draculaTheme.pink
                    }
                  }}
                  aria-label="add"
                  onClick={handleOpen}
                  disabled={!canSendMessage}
                >
                  <AddIcon />
                </Fab>
              </span>
            </Tooltip>
          )}
          
          <Dialog
            fullScreen={fullScreen}
            open={open}
            onClose={handleClose}
            PaperProps={{
              style: {
                position: 'absolute',
                bottom: 0,
                right: 80,
                maxWidth: fullScreen ? '100%' : '60%',
                width: '100%',
                borderRadius: 5,
                backgroundColor: draculaTheme.background,
                color: draculaTheme.foreground,
                border: 'none'
              }
            }}
          >
            <Box sx={{ p: 2 }}>
              <Grid container alignItems="center">
                <Grid item xs={11.5}>
                  <TextField
                    autoFocus
                    margin="dense"
                    label="Your Message"
                    type="text"
                    fullWidth
                    variant="standard"
                    value={message}
                    onChange={(e) => setMessage(e.target.value)}
                    onKeyPress={(e) => {
                      if (e.key === 'Enter' && !e.shiftKey && canSendMessage) {
                        e.preventDefault();
                        handleSendMessage();
                      }
                    }}
                    sx={{
                      '& .MuiInputBase-input': {
                        color: draculaTheme.foreground,
                      },
                      '& .MuiInputLabel-root': {
                        color: draculaTheme.comment,
                      },
                      '& .MuiInput-underline:before': {
                        borderBottomColor: draculaTheme.comment,
                      },
                      '& .MuiInput-underline:hover:not(.Mui-disabled):before': {
                        borderBottomColor: draculaTheme.purple,
                      },
                      '& .MuiInput-underline:after': {
                        borderBottomColor: draculaTheme.purple,
                      }
                    }}
                  />
                </Grid>
                <Grid item xs={0.5}>
                  <IconButton
                    sx={{ color: draculaTheme.purple }}
                    onClick={handleSendMessage}
                    disabled={!message.trim() || !canSendMessage}
                  >
                    <SendIcon />
                  </IconButton>
                </Grid>
              </Grid>
            </Box>
          </Dialog>
        </>
      )}

      {/* Mobile message input - collapsible version */}
      {isMobile && conversationId === mostRecentConversation && (
        <>
          {/* Collapsed Button (shown when input is hidden) */}
          {!mobileInputExpanded && !isProcessingUserMessage && (
            <Zoom in={!mobileInputExpanded}>
              <Tooltip title={canSendMessage ? "Send a message" : "Please wait for bot response"}>
                <span style={{ position: 'fixed', bottom: '16px', right: '16px' }}>
                  <Fab
                    sx={{
                      backgroundColor: draculaTheme.purple,
                      '&:hover': {
                        backgroundColor: draculaTheme.pink
                      }
                    }}
                    aria-label="message"
                    onClick={toggleMobileInput}
                    disabled={!canSendMessage}
                  >
                    <MessageIcon />
                  </Fab>
                </span>
              </Tooltip>
            </Zoom>
          )}
          
          {/* Processing indicator (shown when analyzing message) */}
          {isProcessingUserMessage && (
            <Fab
              sx={{
                position: 'fixed', 
                bottom: '16px', 
                right: '16px',
                backgroundColor: draculaTheme.purple
              }}
              disabled
              aria-label="processing"
            >
              <CircularProgress size={24} color="inherit" />
            </Fab>
          )}
          
          {/* Expanded input box */}
          <Collapse in={mobileInputExpanded} timeout="auto">
            <Box
              sx={{
                p: 2,
                position: 'fixed',
                display: 'flex',
                flexDirection: 'column',
                bottom: 0,
                left: 0,
                right: 0,
                width: '100%',
                backgroundColor: draculaTheme.background,
                color: draculaTheme.foreground,
                borderTop: `1px solid ${draculaTheme.comment}`,
                zIndex: 999,
                border: 'none'
              }}
            >
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="subtitle1">Send a message</Typography>
                <IconButton 
                  size="small" 
                  onClick={handleCloseMobileInput}
                  sx={{ color: draculaTheme.foreground }}
                >
                  <CloseIcon />
                </IconButton>
              </Box>
              
              <TextField
                autoFocus
                margin="dense"
                placeholder="Your message..."
                multiline
                rows={2}
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                variant="outlined"
                InputProps={{
                  style: { 
                    color: draculaTheme.foreground, 
                    borderColor: draculaTheme.comment 
                  }
                }}
                sx={{ 
                  mb: 1,
                  '& .MuiOutlinedInput-root': {
                    '& fieldset': {
                      borderColor: draculaTheme.comment,
                      border: 'none'
                    },
                    '&:hover fieldset': {
                      borderColor: draculaTheme.purple,
                      border: 'none'
                    },
                    '&.Mui-focused fieldset': {
                      borderColor: draculaTheme.purple,
                      border: 'none'
                    },
                  }
                }}
              />
              
              <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
                <Button 
                  variant="contained" 
                  endIcon={<SendIcon />}
                  onClick={handleSendMessage}
                  disabled={!message.trim() || !canSendMessage}
                  sx={{ 
                    backgroundColor: draculaTheme.purple,
                    '&:hover': {
                      backgroundColor: draculaTheme.pink
                    }
                  }}
                >
                  Send
                </Button>
              </Box>
            </Box>
          </Collapse>
        </>
      )}
      
      {/* Improved Scroll to Bottom Button */}
      {userHasScrolled && (
        <Zoom in={userHasScrolled}>
          <Fab
            size="medium"
            color="primary"
            sx={{
              position: 'fixed',
              bottom: '80px',
              right: '20px',
              backgroundColor: draculaTheme.purple,
              '&:hover': {
                backgroundColor: draculaTheme.pink
              },
              zIndex: 1000, // Higher z-index to ensure visibility
            }}
            onClick={() => {
              setUserHasScrolled(false);
            }}
            aria-label="scroll to bottom"
          >
            <ArrowDownward />
          </Fab>
        </Zoom>
      )}
      
      {/* User message status - shows processing information */}
      {isProcessingUserMessage && (
        <Box 
          sx={{
            position: 'fixed',
            bottom: canSendMessage ? '70px' : '16px',
            left: '20px',
            backgroundColor: 'rgba(40, 42, 54, 0.9)',
            color: draculaTheme.foreground,
            padding: '8px 16px',
            borderRadius: '20px',
            zIndex: 10,
            boxShadow: '0 2px 10px rgba(0,0,0,0.2)',
            display: 'flex',
            alignItems: 'center',
            gap: 1,
            border: 'none'
          }}
        >
          <CircularProgress size={16} sx={{ color: draculaTheme.purple }} />
          <Typography variant="caption">Waiting for AI response...</Typography>
        </Box>
      )}
    </div>
  );
}

export default ConversationDetails;